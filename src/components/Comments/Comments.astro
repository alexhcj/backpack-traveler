---
import { getCollection, type CollectionEntry } from "astro:content";
import type { TCommentWithChildren } from "../../types/comments";
import CommentForm from "../shared/CommentForm.astro";
import CommentThread from "./CommentThread.astro";

interface Props {
    postSlug: string;
}

const { postSlug } = Astro.props;

const allComments: CollectionEntry<"comments">[] =
    await getCollection("comments");

const postComments = allComments.filter(
    (comment) => comment.data.postSlug === postSlug,
);

// Build comment hierarchy
function buildCommentHierarchy(
    comments: CollectionEntry<"comments">[],
): TCommentWithChildren[] {
    const commentMap = new Map<string, TCommentWithChildren>();
    const rootComments: TCommentWithChildren[] = [];

    // First, create a map of all comments
    comments.forEach((comment) => {
        commentMap.set(comment.id, {
            ...comment,
            children: [],
        });
    });

    // Then, build the hierarchy
    comments.forEach((comment) => {
        const commentWithChildren = commentMap.get(comment.id);

        if (comment.data.parentId && commentMap.has(comment.data.parentId)) {
            // This is a reply, add it to parent's children
            const parent = commentMap.get(comment.data.parentId);
            if (parent && commentWithChildren) {
                parent.children.push(commentWithChildren);

                // Sort children by date
                parent.children.sort(
                    (a, b) => a.data.date.getTime() - b.data.date.getTime(),
                );
            }
        } else {
            // This is a root comment
            if (commentWithChildren) {
                rootComments.push(commentWithChildren);
            }
        }
    });

    // Sort root comments by date (newest first)
    rootComments.sort((a, b) => b.data.date.getTime() - a.data.date.getTime());

    return rootComments.slice(0, 6); // Limit to 6 main threads
}

const commentHierarchy = buildCommentHierarchy(postComments);
---

<section class="section">
    {
        commentHierarchy.length > 0 && (
            <div>
                <h3 class="title">Comments:</h3>
                <div class="list">
                    {commentHierarchy.map((comment) => (
                        <CommentThread comment={comment} level={1} />
                    ))}
                </div>
            </div>
        )
    }
    <h3 class="title">Post a comment</h3>
    <CommentForm postSlug={postSlug} />
</section>

<style>
    .section {
        padding-top: 60px;
    }
    .title {
        margin-top: 25px;
        margin-bottom: 26px;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-m);
        line-height: 1.33em;
        font-size: 19px;
        font-weight: var(--weight-regular);
    }
    .list {
        display: flex;
        flex-direction: column;
        gap: 40px;
        padding-bottom: 48px;
    }
</style>

<script>
    import type { ICommentFormData } from "../../types/comments";

    // Handle comment form submission
    const handleSubmit = async (data: ICommentFormData) => {
        try {
            const submitBtn = document.querySelector(
                ".form .btn-submit",
            ) as HTMLButtonElement;

            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = "Submitting...";
            }

            const formData = new FormData();

            if (data.parentId) formData.append("parentId", data.parentId);
            formData.append("postSlug", data.postSlug);
            formData.append("name", data.name);
            formData.append("email", data.email);
            formData.append("message", data.message);
            if (data.saveAuthorData) formData.append("saveAuthorData", "on");

            const response = await fetch("/api/comments", {
                method: "POST",
                body: formData,
            });

            const result = await response.json();

            if (response.ok) {
                console.log("Success:", result);

                if (result.saveAuthorData && result.authorData) {
                    localStorage.setItem(
                        "comment-author-data",
                        JSON.stringify(result.authorData),
                    );
                }

                alert(result.message);
                window.location.reload();
            } else {
                throw new Error(result.error || "Failed to submit comment");
            }
        } catch (error) {
            console.error("Error submitting comment:", error);
            alert(
                error instanceof Error
                    ? error.message
                    : "Failed to submit comment. Please try again.",
            );
        } finally {
            const submitBtn = document.querySelector(
                ".form .btn-submit",
            ) as HTMLButtonElement;
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = "Submit";
            }
        }
    };

    // Load saved author data
    function loadSavedAuthorData() {
        try {
            const savedData = localStorage.getItem("comment-author-data");
            if (savedData) {
                const authorData = JSON.parse(savedData);
                return authorData;
            }
        } catch (error) {
            console.error("Error loading saved author data:", error);
        }
        return null;
    }

    // Check if user is the author of a comment and hide reply button
    function checkAndHideOwnCommentReplies() {
        const savedData = loadSavedAuthorData();
        if (!savedData || !savedData.name || !savedData.email) return;

        const currentUserName = savedData.name.toLowerCase().trim();
        const currentUserEmail = savedData.email.toLowerCase().trim();

        // Find all comments
        const comments = document.querySelectorAll(".comment");

        comments.forEach((comment) => {
            const commentAuthorName = (
                comment.getAttribute("data-author-name") || ""
            )
                .toLowerCase()
                .trim();
            const commentAuthorEmail = (
                comment.getAttribute("data-author-email") || ""
            )
                .toLowerCase()
                .trim();

            // If the current user is the author of this comment (match both name AND email)
            if (
                commentAuthorName === currentUserName &&
                commentAuthorEmail === currentUserEmail
            ) {
                const replyButton = comment.querySelector(
                    ".btn-reply",
                ) as HTMLElement;
                const actionsDiv = comment.querySelector(".actions");

                if (replyButton && actionsDiv) {
                    // Hide the reply button
                    replyButton.style.display = "none";
                }
            }
        });
    }

    // Pre-fill form with saved data
    function prefillForm(form: HTMLFormElement) {
        const savedData = loadSavedAuthorData();
        if (savedData) {
            const nameInput = form.querySelector(
                'input[name="name"]',
            ) as HTMLInputElement;
            const emailInput = form.querySelector(
                'input[name="email"]',
            ) as HTMLInputElement;
            const saveDataCheckbox = form.querySelector(
                'input[name="saveAuthorData"]',
            ) as HTMLInputElement;

            if (nameInput && !nameInput.value)
                nameInput.value = savedData.name || "";
            if (emailInput && !emailInput.value)
                emailInput.value = savedData.email || "";
            if (saveDataCheckbox) saveDataCheckbox.checked = true;
        }
    }

    // Toggle thread visibility
    function toggleThread(targetId: string, button: HTMLButtonElement) {
        const threadElement = document.querySelector(
            `[data-thread-id="${targetId}"]`,
        );
        const childrenElement = threadElement?.querySelector(
            `[data-children="${targetId}"]`,
        );

        if (!childrenElement || !button) return;

        const isHidden = childrenElement.classList.contains("hidden");
        const toggleText = button.querySelector(".toggle-text");
        const count = button.dataset.count || "0";

        if (isHidden) {
            childrenElement.classList.remove("hidden");
            childrenElement.classList.add("show");
            button.classList.add("expanded");
            if (toggleText) toggleText.textContent = `Hide thread (${count})`;
        } else {
            childrenElement.classList.add("hidden");
            childrenElement.classList.remove("show");
            button.classList.remove("expanded");
            if (toggleText) toggleText.textContent = `Show thread (${count})`;
        }
    }

    // Main event listener
    document.addEventListener("DOMContentLoaded", function () {
        document.addEventListener("click", function (e) {
            const target = e.target as HTMLElement;

            // Handle thread toggle
            if (
                target.matches('[data-action="toggle-thread"]') ||
                target.closest('[data-action="toggle-thread"]')
            ) {
                e.preventDefault();
                const button = target.closest(
                    '[data-action="toggle-thread"]',
                ) as HTMLButtonElement;
                const targetId = button?.dataset.target;

                if (targetId && button) {
                    toggleThread(targetId, button);
                }
            }

            // Handle reply button clicks
            if (target.matches('[data-action="show-reply"]')) {
                e.preventDefault();

                const commentContainer = target.closest(".comment");

                // Check if user is trying to reply to their own comment
                const savedData = loadSavedAuthorData();
                if (savedData && savedData.name && savedData.email) {
                    const commentAuthorName = (
                        commentContainer?.getAttribute("data-author-name") || ""
                    )
                        .toLowerCase()
                        .trim();
                    const commentAuthorEmail = (
                        commentContainer?.getAttribute("data-author-email") ||
                        ""
                    )
                        .toLowerCase()
                        .trim();
                    const currentUserName = savedData.name.toLowerCase().trim();
                    const currentUserEmail = savedData.email
                        .toLowerCase()
                        .trim();

                    if (
                        commentAuthorName === currentUserName &&
                        commentAuthorEmail === currentUserEmail
                    ) {
                        alert("You cannot reply to your own comment");
                        return;
                    }
                }

                const replyForm = commentContainer?.querySelector(
                    "[data-reply-form]",
                ) as HTMLElement;
                const form = replyForm?.querySelector(
                    "form",
                ) as HTMLFormElement;

                if (replyForm && form) {
                    replyForm.style.display = "block";
                    target.style.display = "none";

                    prefillForm(form);

                    setTimeout(() => {
                        const messageInput = replyForm.querySelector(
                            'textarea[name="message"]',
                        ) as HTMLTextAreaElement;
                        messageInput?.focus();
                    }, 100);
                }
            }

            // Handle cancel buttons
            if (target.matches('[data-action="cancel"]')) {
                e.preventDefault();

                const replyForm = target.closest(
                    "[data-reply-form]",
                ) as HTMLElement;
                const commentContainer = target.closest(".comment");
                const replyButton = commentContainer?.querySelector(
                    '[data-action="show-reply"]',
                ) as HTMLElement;

                if (replyButton) {
                    replyButton.style.display = "block";
                }

                if (replyForm) {
                    replyForm.style.display = "none";

                    const form = replyForm.querySelector("form");
                    if (form) form.reset();
                }
            }
        });

        // Handle form submission
        document.addEventListener("submit", function (e) {
            const target = e.target as HTMLFormElement;

            if (target.matches(".form")) {
                e.preventDefault();

                const formData = new FormData(target);
                const parentId = target.dataset.parentId;
                const postSlug = target.dataset.postSlug;

                const data: ICommentFormData = {
                    parentId: parentId || undefined,
                    postSlug: postSlug || "",
                    name: formData.get("name") as string,
                    email: formData.get("email") as string,
                    message: formData.get("message") as string,
                    saveAuthorData: formData.get("saveAuthorData") === "on",
                };

                // Check if user is trying to reply to their own comment
                if (parentId) {
                    const parentComment = document.querySelector(
                        `[data-comment-id="${parentId}"]`,
                    );

                    if (parentComment) {
                        const parentAuthorName = (
                            parentComment.getAttribute("data-author-name") || ""
                        )
                            .toLowerCase()
                            .trim();
                        const parentAuthorEmail = (
                            parentComment.getAttribute("data-author-email") ||
                            ""
                        )
                            .toLowerCase()
                            .trim();

                        const currentName = data.name.toLowerCase().trim();
                        const currentEmail = data.email.toLowerCase().trim();

                        // Check if both name AND email match the parent comment author
                        if (
                            parentAuthorName === currentName &&
                            parentAuthorEmail === currentEmail
                        ) {
                            alert("You cannot reply to your own comment");
                            return;
                        }
                    }
                }

                handleSubmit(data);
            }
        });

        // Handle saveAuthorData checkbox changes
        document.addEventListener("change", function (e) {
            const target = e.target as HTMLInputElement;

            if (target.matches('input[name="saveAuthorData"]')) {
                // If checkbox is unchecked, clear saved data from localStorage
                if (!target.checked) {
                    try {
                        localStorage.removeItem("comment-author-data");
                    } catch (error) {
                        console.error("Error clearing author data:", error);
                    }
                }
            }
        });

        // Pre-fill all forms on page load
        const allForms = document.querySelectorAll(".form");
        allForms.forEach((form) => {
            prefillForm(form as HTMLFormElement);
        });

        // Check and hide reply buttons for author's own comments
        checkAndHideOwnCommentReplies();
    });
</script>
